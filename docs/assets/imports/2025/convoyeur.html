<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulateur Convoyeur - Frottement</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; margin: 0; padding: 0; background-color: #f5f5f5; display: flex; flex-direction: column; align-items: center; }
        .container { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); width: 90%; max-width: 800px; margin-top: 20px; }
        h2 { text-align: center; color: #333; margin-top: 0; }
        canvas { border: 1px solid #ddd; background: #fff; width: 100%; height: 400px; display: block; margin-bottom: 20px; }
        .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; background: #eee; padding: 15px; border-radius: 5px; }
        .control-group { display: flex; flex-direction: column; }
        label { font-weight: bold; font-size: 0.9em; margin-bottom: 5px; }
        input[type=range] { width: 100%; cursor: pointer; }
        .values { display: flex; justify-content: space-between; margin-top: 5px; font-size: 0.85em; color: #555; }
        .status { text-align: center; font-weight: bold; padding: 10px; margin-top: 10px; border-radius: 4px; }
        .status.static { background-color: #d4edda; color: #155724; }
        .status.sliding { background-color: #f8d7da; color: #721c24; }
        .legend { font-size: 0.8em; margin-top: 10px; display: flex; gap: 15px; justify-content: center; }
        .dot { height: 10px; width: 10px; border-radius: 50%; display: inline-block; margin-right: 5px; }
    </style>
</head>
<body>

<div class="container">
    <h2>Étude du Convoyeur (Plan Incliné)</h2>
    <canvas id="simCanvas" width="800" height="400"></canvas>
    
    <div class="legend">
        <span><span class="dot" style="background:blue"></span>Poids (P)</span>
        <span><span class="dot" style="background:orange"></span>Réaction Normale (Fn)</span>
        <span><span class="dot" style="background:red"></span>Frottement (Ff/Ft)</span>
        <span><span class="dot" style="background:rgba(0,255,0,0.3)"></span>Cône d'adhérence</span>
    </div>

    <div id="statusBox" class="status static">STATIQUE : La boîte tient</div>

    <div class="controls">
        <div class="control-group">
            <label for="angleRange">Angle de la pente (α)</label>
            <input type="range" id="angleRange" min="0" max="70" value="30" step="1">
            <div class="values">
                <span id="angleVal">30°</span>
            </div>
        </div>

        <div class="control-group">
            <label for="muRange">Coefficient de frottement (μ)</label>
            <input type="range" id="muRange" min="0.1" max="1.0" value="0.7" step="0.05">
            <div class="values">
                <span>0.1 (Glace)</span>
                <span id="muVal">0.7</span>
                <span>1.0 (Caoutchouc)</span>
            </div>
        </div>
        
        <div class="control-group">
            <label for="massRange">Masse de la boîte (kg)</label>
            <input type="range" id="massRange" min="0.1" max="5.0" value="0.3" step="0.1">
             <div class="values">
                <span id="massVal">0.3 kg</span>
            </div>
        </div>
    </div>
</div>

<script>
    // Configuration
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');
    const g = 9.81;
    
    // Inputs
    const angleInput = document.getElementById('angleRange');
    const muInput = document.getElementById('muRange');
    const massInput = document.getElementById('massRange');
    
    // Displays
    const angleDisplay = document.getElementById('angleVal');
    const muDisplay = document.getElementById('muVal');
    const massDisplay = document.getElementById('massVal');
    const statusBox = document.getElementById('statusBox');

    // State
    let state = {
        angleDeg: 30,
        mu: 0.7,
        mass: 0.3
    };

    function update() {
        // Update state
        state.angleDeg = parseFloat(angleInput.value);
        state.mu = parseFloat(muInput.value);
        state.mass = parseFloat(massInput.value);

        // Update Text
        angleDisplay.textContent = state.angleDeg + "°";
        muDisplay.textContent = state.mu.toFixed(2);
        massDisplay.textContent = state.mass.toFixed(2) + " kg";

        draw();
    }

    function drawArrow(ctx, fromX, fromY, toX, toY, color, text) {
        const headlen = 10; 
        const dx = toX - fromX;
        const dy = toY - fromY;
        const angle = Math.atan2(dy, dx);
        
        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        ctx.lineWidth = 3;
        
        ctx.beginPath();
        ctx.moveTo(fromX, fromY);
        ctx.lineTo(toX, toY);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(toX, toY);
        ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
        ctx.fill();

        if(text) {
            ctx.font = "bold 14px Arial";
            ctx.fillStyle = color;
            ctx.fillText(text, toX + 10, toY);
        }
    }

    function draw() {
        // Clear
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height / 2 +30; 

        const rad = state.angleDeg * Math.PI / 180;
        
        // Calculs Physiques
        const P_mag = state.mass * g; // Valeur réelle en Newtons
        
        // --- GESTION DE L'ÉCHELLE D'AFFICHAGE ---
        // Calibrage pour que 5kg (approx 50N) tienne dans ~200px
        const PIXELS_PER_NEWTON = 4; 
        
        // Le vecteur Poids varie maintenant visuellement avec la masse
        const visual_P_len = P_mag * PIXELS_PER_NEWTON; 
        
        const Fn_mag = P_mag * Math.cos(rad);
        const Ft_mag = P_mag * Math.sin(rad); 
        const Flim_mag = state.mu * Fn_mag;
        
        // Calcul des longueurs visuelles (proportionnalité géométrique)
        // Si P_mag correspond à visual_P_len, alors Fn_mag correspond à...
        const visual_Fn_len = Fn_mag * PIXELS_PER_NEWTON;
        const visual_Ft_len = Ft_mag * PIXELS_PER_NEWTON;
        
        // Pour Ff (frottement affiché), on regarde si ça glisse
        let isSliding = Ft_mag > Flim_mag;
        
        // Si ça glisse, la force de frottement est limitée à Flim
        // Si ça tient, la force de frottement est égale à l'effort tangentiel (Ft)
        const Ff_real_mag = isSliding ? Flim_mag : Ft_mag;
        
        // Longueur visuelle du frottement
        const visual_Ff_len = (Ff_real_mag / P_mag) * visual_P_len;

        // Mise à jour du texte de statut
        if(isSliding) {
            statusBox.className = "status sliding";
            statusBox.textContent = "GLISSEMENT ! (Ft > Flim) | " + Ft_mag.toFixed(2) + "N > " + Flim_mag.toFixed(2) + "N";
        } else {
            statusBox.className = "status static";
            statusBox.textContent = "ADHÉRENCE (Équilibre) | Ft : " + Ft_mag.toFixed(2) + "N < Max : " + Flim_mag.toFixed(2) + "N";
        }

        // --- DESSIN ---
        
        ctx.save();
        ctx.translate(centerX, centerY);
        
        // 1. Rotation du contexte pour dessiner la pente et la boîte
        ctx.save();
        ctx.rotate(rad); // Attention: rotation positive = sens horaire (la pente descend vers la droite)
        
        // Dessin de la rampe
        ctx.fillStyle = "#ccc";
        ctx.fillRect(-300, 0, 600, 10);
        
        // Dessin de la boîte
        ctx.fillStyle = isSliding ? "#e57373" : "#4db6ac"; 
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 2;
        // La boîte est POSÉE sur la rampe. 
        // Dans le repère tourné : Y positif est vers le "bas" de l'écran (dans la pente), Y négatif vers le "ciel" local.
        ctx.fillRect(-40, -40, 80, 40);
        ctx.strokeRect(-40, -40, 80, 40);
        
        // Centre de gravité local (milieu de la boite)
        const cgX = 0;
        const cgY = -20;
        
        // 2. Vecteurs en repère LOCAL (tourné)
        
        // Fn (Normale) : Perpendiculaire à la pente, vers le haut local (Y négatif)
        drawArrow(ctx, cgX, cgY, cgX, cgY - visual_Fn_len, "orange", "Fn");
        
        // Ff (Frottement) : Opposé au mouvement probable.
        // Le mouvement probable est vers la descente (X positif local). Donc Ff vers X négatif.
        drawArrow(ctx, cgX, cgY, cgX - visual_Ff_len, cgY, "red", "Ff");
        
        // 3. Cône de frottement (autour de la normale)
        const coneAngle = Math.atan(state.mu);
        const coneLen = 220; // Un peu plus grand que P pour être visible
        
        ctx.beginPath();
        ctx.moveTo(cgX, cgY);
        // Le cône est centré sur l'axe Y négatif local (la normale)
        // Attention aux coord : -sin pour X (gauche), -cos pour Y (haut)
        ctx.lineTo(cgX - Math.sin(coneAngle)*coneLen, cgY - Math.cos(coneAngle)*coneLen);
        ctx.lineTo(cgX + Math.sin(coneAngle)*coneLen, cgY - Math.cos(coneAngle)*coneLen);
        ctx.closePath(); // Fermer pour remplir
        
        ctx.fillStyle = "rgba(0, 255, 0, 0.1)"; 
        ctx.fill();
        ctx.strokeStyle = "rgba(0, 200, 0, 0.5)";
        ctx.setLineDash([5, 5]);
        ctx.stroke();
        ctx.setLineDash([]);
        
        ctx.restore(); // Fin repère incliné
        
        // 4. Vecteur Poids (P) - Doit être vertical ABSOLU
        // Comme nous sommes translatés mais plus rotatés, Y positif est vers le bas de l'écran.
        // Le CG est à (0, -20) DANS LE REPÈRE TOURNÉ. Il faut trouver ses coordonnées ici.
        // Coord du CG après rotation : 
        // x' = x*cos - y*sin = 0 - (-20)*sin(rad) = 20*sin(rad)
        // y' = x*sin + y*cos = 0 + (-20)*cos(rad) = -20*cos(rad)
        
        const absCgX = 20 * Math.sin(rad);
        const absCgY = -20 * Math.cos(rad);
        
        // Dessin de P (vertical vers le bas)
        drawArrow(ctx, absCgX, absCgY, absCgX, absCgY + visual_P_len, "blue", "P");
        
        ctx.restore(); // Fin translation globale
    }

    // Init
    angleInput.addEventListener('input', update);
    muInput.addEventListener('input', update);
    massInput.addEventListener('input', update);
    
    // Resize responsive
    window.addEventListener('resize', () => {
        // Optionnel : ajuster canvas.width si besoin
        draw();
    });

    update();
</script>

</body>
</html>